# 6/8/2024 - 4th Update!

Ok, after review this, the problem appeared to be that I did a little silly. In pathing, turns out that I just set x to 0 instead of distributing. This mistake makes since, since I should actually distribute the front of the equation to the x and the rest of it, move the rest of it to the $b$ (in $y=mx+b$) and the x part would be the $m$. Basically:

This is the correct equation: 

$\left(\frac{4y_{2}-3y_{1}-y_{3}+4u\left(y_{3}+y_{1}-2y_{2}\right)}{4x_{2}-3x_{1}-x_{3}+4u\left(x_{3}+x_{1}-2x_{2}\right)}\right)x+\left(\frac{4y_{2}-3y_{1}-y_{3}+4u\left(y_{3}+y_{1}-2y_{2}\right)}{4x_{2}-3x_{1}-x_{3}+4u\left(x_{3}+x_{1}-2x_{2}\right)}\right)\left(-x_{1}+2u\left(-x_{2}+\frac{3x_{1}}{4}+\frac{x_{3}}{4}\right)\right)+y_{1}-2u\left(-y_{2}+\frac{3y_{1}}{4}+\frac{y_{3}}{4}\right)$

That front part is the $mx$ and that back part is the $b$. After fixing this, we get a nice little:

![yippee](</updatelogs/images/06082024 - 1.png>)

Yay! It works now! It also appears that `pathing.py` also provides some reusable code if you want to make some basic Algebra 1 stuff. I don't know, I should probably delete useless stuff, but I will say what I always say: *"It may come helpful in the future..."* (keyword: *may*)

There is also now a `roundf(n,m)` function! It will round n with m digits after the decimal place. This is because storing floats that are way to accurate will not be useful, and will probably just be a waste of space. The accuracy defaults to 3 and can be configured in settings (`PATH_FLOAT_ACCURACY`)! It'll only be rounded at the final output, which is for `path3coords()`! `roundp()` rounds the `(x,y)` components of the point to `PATH_FLOAT_ACCURACY` after the decimal point (using `roundf()`) and returns it!

Anyways, I'll be back later today after I'm done doing this tutoring stuff. Yes, I should be teaching students right now, but my turn to teach already happened so...

One more thing, after setting up a little speed test, from the range of (2500,2500) to (-2500,-2500) and steps set to 60 (for 60 FPS), we get an average of 0.000954 seconds per test (n=1000)! If you're feeling a little silly, and want to go for 1000 steps (1000 FPS), you get an average of 0.0153 seconds (n=1000)! Remember, I am currently supposed to be tutoring and zoom is running in the background. Also, 1000 FPS is not realistic. Ok, we seem to be getting consistently around 0.001 seconds for any test with 60 FPS (large coordinate ranges don't seem to affect this). Very nice!

Ok, I need to go tutor some kids now.